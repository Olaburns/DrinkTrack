<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Drink Tracker - Live Dashboard</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;900&family=JetBrains+Mono:wght@400;600&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="/styles.css">
  <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/qrcodejs@1.0.0/qrcode.min.js"></script>
  <style>
    /* Hide permanent QR on mobile, show button instead */
    @media (max-width: 768px) {
      #permanentQR {
        display: none !important;
      }
    }
    /* Hide button on desktop, show permanent QR instead */
    @media (min-width: 769px) {
      [data-testid="button-show-qr"] {
        display: none !important;
      }
    }
  </style>
</head>
<body>
  <div class="app-container">
    <!-- Header -->
    <header class="header">
      <h1 class="header-title">
        <span>üìä</span>
        <span>Drink Tracker Dashboard</span>
      </h1>
      <div style="display: flex; align-items: center; gap: 1rem;">
        <div class="live-indicator">
          <div class="live-dot"></div>
          <span class="live-text">Live</span>
        </div>
        <button class="btn btn-outline" onclick="showQRModal()" data-testid="button-show-qr">
          <span>üì±</span>
          <span>Join QR</span>
        </button>
        <a href="/control" class="btn btn-outline" data-testid="button-nav-control">
          <span>üç∫</span>
          <span>Control Panel</span>
        </a>
      </div>
    </header>

    <!-- Main Content -->
    <main class="main-content">
      <!-- Chart Controls -->
      <div style="display: flex; justify-content: flex-end; padding: 0 1rem 0.5rem; gap: 0.5rem;">
        <button id="toggleMode" class="btn btn-outline" onclick="toggleChartMode()" data-testid="button-toggle-mode">
          <span id="modeLabel">Switch to Cumulative</span>
        </button>
      </div>
      
      <!-- Chart Container -->
      <div class="chart-container">
        <div id="chart"></div>
      </div>

      <!-- Legend -->
      <div class="legend" id="legend">
        <!-- Dynamic legend items will be inserted here -->
      </div>

      <!-- Permanent QR Code (desktop only) -->
      <div id="permanentQR" style="margin: 1.5rem 1rem; padding: 1.5rem; background: hsl(220, 15%, 10%); border-radius: 0.75rem; border: 1px solid hsl(220, 15%, 16%);">
        <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem;">
          <h3 style="font-size: 1rem; font-weight: 600; color: hsl(220, 10%, 95%); margin: 0;">Scan to Join Event</h3>
          <div id="permanentQRCode" style="background: white; padding: 0.75rem; border-radius: 0.5rem;"></div>
          <p style="text-align: center; color: hsl(220, 9%, 46%); font-size: 0.875rem; margin: 0;">
            Scan with your phone to track your drinks
          </p>
        </div>
      </div>
    </main>
  </div>

  <script>
    // Initialize ECharts
    const chartDom = document.getElementById('chart');
    const chart = echarts.init(chartDom, null, {
      renderer: 'canvas',
      useDirtyRect: false
    });

    // Chart state (for rolling 60-min window from SSE)
    let chartData = {
      times: [],
      series: {},
      events: []
    };

    // Historical chart data (all data for cumulative mode)
    let historicalChartData = {
      times: [],
      series: {},
      events: []
    };

    let drinks = [];
    
    // Chart mode: 'normal' or 'cumulative'
    let chartMode = localStorage.getItem('chartMode') || 'normal';
    
    // Update button label on load
    document.getElementById('modeLabel').textContent = 
      chartMode === 'normal' ? 'Switch to Cumulative' : 'Switch to Normal';

    // Color palette
    const colorPalette = [
      'hsl(262, 83%, 58%)',
      'hsl(198, 93%, 60%)',
      'hsl(340, 82%, 52%)',
      'hsl(48, 96%, 53%)',
      'hsl(280, 67%, 47%)',
      'hsl(171, 77%, 47%)'
    ];
    
    // Fetch historical stats
    async function fetchHistoricalStats() {
      try {
        const response = await fetch('/api/stats/historical');
        const data = await response.json();
        
        // Process historical buckets
        historicalChartData.times = data.buckets.map(b => b.timestamp);
        historicalChartData.events = data.allEvents || [];
        historicalChartData.series = {};
        
        // Build series data
        data.buckets.forEach((bucket, index) => {
          Object.keys(bucket.drinks).forEach(drinkName => {
            if (!historicalChartData.series[drinkName]) {
              historicalChartData.series[drinkName] = new Array(data.buckets.length).fill(0);
            }
            historicalChartData.series[drinkName][index] = bucket.drinks[drinkName];
          });
        });
        
        // Update chart
        chart.setOption(getChartOption(), true);
      } catch (err) {
        console.error('Failed to fetch historical stats:', err);
      }
    }
    
    // Toggle chart mode
    async function toggleChartMode() {
      chartMode = chartMode === 'normal' ? 'cumulative' : 'normal';
      localStorage.setItem('chartMode', chartMode);
      document.getElementById('modeLabel').textContent = 
        chartMode === 'normal' ? 'Switch to Cumulative' : 'Switch to Normal';
      
      // Fetch historical data when switching to cumulative mode
      if (chartMode === 'cumulative') {
        await fetchHistoricalStats();
      } else {
        chart.setOption(getChartOption(), true);
      }
    }

    // Chart options
    function getChartOption() {
      // Select data source based on mode
      const dataSource = chartMode === 'cumulative' ? historicalChartData : chartData;
      
      const seriesData = Object.keys(dataSource.series).map((drinkName, index) => {
        const drink = drinks.find(d => d.name === drinkName);
        const color = drink?.color || colorPalette[index % colorPalette.length];
        
        // Calculate cumulative data if in cumulative mode
        let data = dataSource.series[drinkName];
        if (chartMode === 'cumulative') {
          let cumSum = 0;
          data = data.map(val => {
            cumSum += val;
            return cumSum;
          });
        }
        
        return {
          name: drinkName,
          type: 'line',
          stack: chartMode === 'normal' ? 'total' : null,
          areaStyle: chartMode === 'normal' ? {
            opacity: 0.3
          } : null,
          smooth: true,
          symbol: 'none',
          lineStyle: {
            width: 2
          },
          emphasis: {
            focus: 'series'
          },
          data: data,
          itemStyle: {
            color: color
          }
        };
      });

      // Event markers - use the appropriate events based on mode
      const markLines = dataSource.events.map(event => {
        const eventColor = event.color || '#F59E0B'; // Default amber
        return {
          xAxis: event.at,
          label: {
            formatter: event.label,
            position: 'insideEndTop',
            rotate: 90,
            color: eventColor,
            fontSize: 11,
            fontWeight: 'bold'
          },
          lineStyle: {
            color: eventColor,
            width: 2,
            type: 'solid',
            opacity: 0.7
          }
        };
      });

      // Attach markLine to first series if we have both data and events
      if (seriesData.length > 0 && markLines.length > 0) {
        seriesData[0].markLine = { data: markLines };
      }

      return {
        backgroundColor: 'transparent',
        tooltip: {
          trigger: 'axis',
          backgroundColor: 'hsl(220, 10%, 18%)',
          borderColor: 'hsl(220, 10%, 24%)',
          textStyle: {
            color: 'hsl(220, 10%, 95%)'
          },
          axisPointer: {
            type: 'cross',
            crossStyle: {
              color: 'hsl(220, 8%, 65%)'
            }
          }
        },
        legend: {
          show: false
        },
        grid: {
          left: '3%',
          right: '4%',
          bottom: '3%',
          top: '3%',
          containLabel: true
        },
        xAxis: {
          type: 'category',
          boundaryGap: false,
          data: dataSource.times,
          axisLine: {
            lineStyle: {
              color: 'hsl(220, 10%, 20%)'
            }
          },
          axisLabel: {
            color: 'hsl(220, 8%, 65%)',
            formatter: function(value) {
              const date = new Date(value);
              return date.toLocaleTimeString('en-US', { 
                hour: '2-digit', 
                minute: '2-digit',
                hour12: false
              });
            }
          },
          splitLine: {
            lineStyle: {
              color: 'hsl(220, 10%, 20%)',
              opacity: 0.2
            }
          }
        },
        yAxis: {
          type: 'value',
          axisLine: {
            lineStyle: {
              color: 'hsl(220, 10%, 20%)'
            }
          },
          axisLabel: {
            color: 'hsl(220, 8%, 65%)'
          },
          splitLine: {
            lineStyle: {
              color: 'hsl(220, 10%, 20%)',
              opacity: 0.2
            }
          }
        },
        series: seriesData.length > 0 ? seriesData : [{
          name: 'No Data',
          type: 'line',
          data: [],
          markLine: markLines.length > 0 ? { data: markLines } : undefined
        }]
      };
    }

    // Update legend
    function updateLegend() {
      const legendContainer = document.getElementById('legend');
      legendContainer.innerHTML = '';

      drinks.forEach((drink, index) => {
        const totalCount = chartData.series[drink.name]?.reduce((sum, val) => sum + val, 0) || 0;
        
        // Get the color for this drink (same as chart)
        const drinkColor = drink.color || colorPalette[index % colorPalette.length];
        
        const item = document.createElement('div');
        item.className = 'legend-item';
        // Add colored border matching the chart series
        item.style.borderColor = drinkColor;
        item.style.borderWidth = '2px';
        item.style.borderStyle = 'solid';
        
        let iconHtml;
        if (drink.imageUrl) {
          iconHtml = `<img src="${drink.imageUrl}" alt="${drink.name}" class="legend-avatar">`;
        } else if (drink.emoji) {
          iconHtml = `<span class="legend-emoji">${drink.emoji}</span>`;
        } else {
          iconHtml = `<div class="legend-color" style="background: ${drinkColor}"></div>`;
        }
        
        item.innerHTML = `
          ${iconHtml}
          <span class="legend-name">${drink.name}</span>
          <span class="legend-count">${totalCount}</span>
        `;
        
        legendContainer.appendChild(item);
      });
    }

    // Process stats data
    function processStats(stats) {
      const times = [];
      const seriesMap = {};

      // Initialize series for all drinks
      drinks.forEach(drink => {
        seriesMap[drink.name] = [];
      });

      // Process buckets
      stats.buckets.forEach(bucket => {
        times.push(bucket.timestamp);
        
        // Add data for each drink
        drinks.forEach(drink => {
          const count = bucket.drinks[drink.name] || 0;
          seriesMap[drink.name].push(count);
        });
      });

      chartData.times = times;
      chartData.series = seriesMap;
      
      // Map events to nearest bucket timestamps for markLine compatibility
      chartData.events = (stats.recentEvents || []).map(event => {
        const eventTime = new Date(event.at).getTime();
        
        // Find nearest bucket timestamp
        let nearestTimestamp = times[0];
        let minDiff = Math.abs(new Date(times[0]).getTime() - eventTime);
        
        times.forEach(bucketTime => {
          const diff = Math.abs(new Date(bucketTime).getTime() - eventTime);
          if (diff < minDiff) {
            minDiff = diff;
            nearestTimestamp = bucketTime;
          }
        });
        
        return {
          label: event.label,
          color: event.color || '#F59E0B', // Preserve color
          at: nearestTimestamp
        };
      });

      // Update chart
      chart.setOption(getChartOption(), true);
      updateLegend();
    }

    // Fetch drinks
    async function fetchDrinks() {
      try {
        const response = await fetch('/drinks');
        drinks = await response.json();
        updateLegend();
      } catch (err) {
        console.error('Failed to fetch drinks:', err);
      }
    }

    // Setup SSE
    function setupSSE() {
      const eventSource = new EventSource('/events');

      eventSource.addEventListener('stats', (event) => {
        const stats = JSON.parse(event.data);
        processStats(stats);
      });

      eventSource.addEventListener('consumption', (event) => {
        // Stats update will follow
      });

      eventSource.addEventListener('event', (event) => {
        // Stats update will follow
      });

      eventSource.addEventListener('drink-added', (event) => {
        fetchDrinks();
      });

      eventSource.addEventListener('heartbeat', (event) => {
        // Connection alive
      });

      eventSource.onerror = (error) => {
        console.error('SSE error:', error);
      };
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      chart.resize();
    });

    // Generate permanent QR code (for desktop)
    async function generatePermanentQR() {
      const qrContainer = document.getElementById('permanentQRCode');
      if (!qrContainer) return;
      
      // Fetch network info to use LAN IP
      let joinURL = window.location.origin + '/join';
      try {
        const response = await fetch('/api/network-info');
        if (response.ok) {
          const { lanIp, port } = await response.json();
          joinURL = `http://${lanIp}:${port}/join`;
        }
      } catch (err) {
        console.error('Failed to fetch network info:', err);
      }
      
      new QRCode(qrContainer, {
        text: joinURL,
        width: 180,
        height: 180,
        colorDark: '#000000',
        colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.H
      });
    }

    // Initialize
    async function init() {
      await fetchDrinks();
      setupSSE();
      generatePermanentQR();
      
      // Load historical data if starting in cumulative mode
      if (chartMode === 'cumulative') {
        await fetchHistoricalStats();
      } else {
        // Show initial empty state for normal mode
        chart.setOption(getChartOption());
      }
    }

    init();

    // QR Code Modal
    async function showQRModal() {
      const modal = document.getElementById('qrModal');
      modal.classList.remove('hidden');
      
      // Generate QR code
      const qrContainer = document.getElementById('qrcode');
      qrContainer.innerHTML = ''; // Clear previous QR code
      
      // Fetch network info to use LAN IP
      let joinURL = window.location.origin + '/join';
      try {
        const response = await fetch('/api/network-info');
        if (response.ok) {
          const { lanIp, port } = await response.json();
          joinURL = `http://${lanIp}:${port}/join`;
        }
      } catch (err) {
        console.error('Failed to fetch network info:', err);
      }
      
      new QRCode(qrContainer, {
        text: joinURL,
        width: 256,
        height: 256,
        colorDark: '#000000',
        colorLight: '#ffffff',
        correctLevel: QRCode.CorrectLevel.H
      });
    }

    function closeQRModal(event) {
      if (!event || event.target.classList.contains('modal-overlay')) {
        document.getElementById('qrModal').classList.add('hidden');
      }
    }
  </script>

  <!-- QR Code Modal -->
  <div id="qrModal" class="modal-overlay hidden" onclick="closeQRModal(event)">
    <div class="modal" onclick="event.stopPropagation()" style="max-width: 400px;">
      <div class="modal-header">
        <h2 class="modal-title">Scan to Join</h2>
      </div>
      
      <div style="display: flex; flex-direction: column; align-items: center; gap: 1rem; padding: 2rem;">
        <div id="qrcode" style="background: white; padding: 1rem; border-radius: 0.5rem;"></div>
        <p style="text-align: center; color: hsl(220, 9%, 46%); font-size: 0.875rem;">
          Scan this QR code with your phone to join the event and start tracking your drinks
        </p>
      </div>
      
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" onclick="closeQRModal()" data-testid="button-close-qr">Close</button>
      </div>
    </div>
  </div>
</body>
</html>
